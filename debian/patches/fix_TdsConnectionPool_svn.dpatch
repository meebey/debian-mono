#! /bin/sh /usr/share/dpatch/dpatch-run
## fix_TdsConnectionPool_r105424_r106448_107325.dpatch by Mirco Bauer <meebey@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Backport of upstream SVN trunk to fix connection pool leaks/stalls, see:
## DP: https://bugzilla.novell.com/show_bug.cgi?id=360157
## DP: r105424:
## DP: Remove unnecessary locks and code refactoring
## DP: r105432:
## DP: Update according to the new return type of TdsConnectionPool.GetConnectionPool()
## DP: r105433:
## DP: Member to keep track of pool status
## DP: r105719:
## DP: Do not call tds.Reset () as it is already done in the connection pool.
## DP: r106448:
## DP: Honor timeout and throw appropriate exception when connections are not available
## DP: r107325:
## DP: TdsConnectionPool.cs: When pooled connection cannot be reset, remove
## DP: it from pool and allow slot to be re-used for a newly established
## DP: connection. Fixes part of bug #360157. When pool is full, and no
## DP: connection becomes available before the connect timeout has elapsed,
## DP: then throw an InvalidOperationException instead of a SqlException.
## DP: r118308:
## DP: TdsConnectionPool.cs: Added TdsConnectionPoolManager.GetConnection
## DP: overload that can be used to retrieve an existing connection pool.
## DP: Modified ResetConnectionPool () to skip free slots in the pool and to
## DP: close pooled connections that are not in use. Pooled connections that
## DP: are in use are now marked as non-pooled so that they are no longer
## DP: returned to the pool when they are closed. Fixes bug #443131.
## DP: SqlConnection.cs: In Close, also remove reference to pool. In Open,
## DP: set TdsConnection.Pooling to false for a non-pooled connection.
## DP: Fixed ClearAllPools to no longer create a new connection for each
## DP: pool. In ClearPool, perform a lookup of the pool to clear using
## DP: the connectionstring as the pool field may refer to another pool
## DP: (as the connectionstring may have changed).
## DP: r112416 (partly):
## DP: track API changes of releasing the connection in the pool.

@DPATCH@
diff -urNad mono-1.9.1+dfsg~/mcs/class/Mono.Data.SybaseClient/Mono.Data.SybaseClient/SybaseConnection.cs mono-1.9.1+dfsg/mcs/class/Mono.Data.SybaseClient/Mono.Data.SybaseClient/SybaseConnection.cs
--- mono-1.9.1+dfsg~/mcs/class/Mono.Data.SybaseClient/Mono.Data.SybaseClient/SybaseConnection.cs	2008-11-19 17:03:21.000000000 +0100
+++ mono-1.9.1+dfsg/mcs/class/Mono.Data.SybaseClient/Mono.Data.SybaseClient/SybaseConnection.cs	2008-11-19 17:04:20.000000000 +0100
@@ -31,6 +31,7 @@
 //
 
 using Mono.Data.Tds.Protocol;
+using MTds = Mono.Data.Tds.Protocol.Tds;
 using System;
 using System.Collections;
 using System.Collections.Specialized;
@@ -77,7 +78,7 @@
 		SybaseDataReader dataReader = null;
 
 		// The TDS object
-		ITds tds;
+		MTds tds;
 
 		#endregion // Fields
 
@@ -229,14 +230,30 @@
 
 		public void Close () 
 		{
-			if (Transaction != null && Transaction.IsOpen)
-				Transaction.Rollback ();
-			if (pooling)
-				pool.ReleaseConnection (tds);
-			else
-				tds.Disconnect ();
-			tds.TdsErrorMessage -= new TdsInternalErrorMessageEventHandler (ErrorHandler);
-			tds.TdsInfoMessage -= new TdsInternalInfoMessageEventHandler (MessageHandler);
+			if (transaction != null && transaction.IsOpen)
+				transaction.Rollback ();
+
+			if (dataReader != null) {
+				if(tds != null) tds.SkipToEnd ();
+				dataReader = null;
+			}
+
+			if (tds != null && tds.IsConnected) {
+				if (pooling && tds.Pooling) {
+#if NET_2_0
+					if(pool != null) pool.ReleaseConnection (ref tds);
+#else
+					if(pool != null) pool.ReleaseConnection (tds);
+#endif
+				}else
+					if(tds != null) tds.Disconnect ();
+			}
+
+			if (tds != null) {
+				tds.TdsErrorMessage -= new TdsInternalErrorMessageEventHandler (ErrorHandler);
+				tds.TdsInfoMessage -= new TdsInternalInfoMessageEventHandler (MessageHandler);
+			}
+
 			ChangeState (ConnectionState.Closed);
 		}
 
diff -urNad mono-1.9.1+dfsg~/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/Tds.cs mono-1.9.1+dfsg/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/Tds.cs
--- mono-1.9.1+dfsg~/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/Tds.cs	2008-11-19 17:03:21.000000000 +0100
+++ mono-1.9.1+dfsg/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/Tds.cs	2008-11-19 17:03:26.000000000 +0100
@@ -102,6 +102,8 @@
 		bool isResultRead = false;
 		bool LoadInProgress = false;
 
+		internal int poolStatus = 0;
+
 		#endregion // Fields
 
 		#region Properties
diff -urNad mono-1.9.1+dfsg~/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/TdsConnectionPool.cs mono-1.9.1+dfsg/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/TdsConnectionPool.cs
--- mono-1.9.1+dfsg~/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/TdsConnectionPool.cs	2008-11-19 17:03:21.000000000 +0100
+++ mono-1.9.1+dfsg/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/TdsConnectionPool.cs	2008-11-19 17:03:26.000000000 +0100
@@ -3,6 +3,7 @@
 //
 // Author:
 //   Lluis Sanchez Gual (lluis@ximian.com)
+//   Christian Hergert (christian.hergert at gmail.com)
 //
 // Copyright (C) 2004 Novell, Inc.
 //
@@ -28,16 +29,23 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 
-using Mono.Data.Tds.Protocol;
 using System;
+#if NET_2_0
+using System.Collections.Generic;
+#else
 using System.Collections;
+#endif
 using System.Threading;
 
 namespace Mono.Data.Tds.Protocol 
 {
 	public class TdsConnectionPoolManager
 	{
+#if NET_2_0
+		Dictionary <string, TdsConnectionPool> pools = new Dictionary <string, TdsConnectionPool> ();
+#else
 		Hashtable pools = new Hashtable ();
+#endif
 		TdsVersion version;
 		
 		public TdsConnectionPoolManager (TdsVersion version)
@@ -49,7 +57,12 @@
 		{
 			lock (pools)
 			{
-				TdsConnectionPool pool = (TdsConnectionPool) pools [connectionString];
+				TdsConnectionPool pool = null;
+#if NET_2_0
+				pools.TryGetValue (connectionString, out pool);
+#else
+				pool = (TdsConnectionPool) pools [connectionString];
+#endif
 				if (pool == null) {
 					pool = new TdsConnectionPool (this, info);
 					pools [connectionString] = pool;
@@ -57,16 +70,28 @@
 				return pool;
 			}
 		}
+
+		public TdsConnectionPool GetConnectionPool (string connectionString)
+		{
+			TdsConnectionPool pool = null;
+#if NET_2_0
+			pools.TryGetValue (connectionString, out pool);
+#else
+			pool = (TdsConnectionPool) pools [connectionString];
+#endif
+			return pool;
+		}
 		
-		public Hashtable GetConnectionPool ()
+#if NET_2_0
+		public IDictionary <string, TdsConnectionPool> GetConnectionPool ()
+#else
+		public IDictionary GetConnectionPool ()
+#endif
 		{
-			lock (pools)
-			{
-				return pools;
-			}
+			return pools;
 		}
 		
-		public virtual ITds CreateConnection (TdsConnectionInfo info)
+		public virtual Tds CreateConnection (TdsConnectionInfo info)
 		{
 			switch (version)
 			{
@@ -102,20 +127,34 @@
 		public int PoolMinSize;
 		public int PoolMaxSize;
 	}
-	
+
 	public class TdsConnectionPool
 	{
-		ArrayList list = new ArrayList ();
+		Tds[] list;
 		TdsConnectionInfo info;
-		bool initialized;
 		bool pooling = true;
-		int activeConnections = 0;
 		TdsConnectionPoolManager manager;
-
+		ManualResetEvent connAvailable;
+		
 		public TdsConnectionPool (TdsConnectionPoolManager manager, TdsConnectionInfo info)
 		{
+			int n = 0;
+			
 			this.info = info;
 			this.manager = manager;
+			list = new Tds[info.PoolMaxSize];
+			
+			// Placeholder for future connections are at the beginning of the array.
+			for (; n < info.PoolMaxSize - info.PoolMinSize; n++)
+				list [n] = null;
+
+			// Pre-populate with minimum number of connections
+			for (; n < list.Length; n++) {
+				list [n] = CreateConnection ();
+			}
+			
+			// Event that notifies a connection is available in the pool
+			connAvailable = new ManualResetEvent (false);
 		}
 
 		public bool Pooling {
@@ -125,124 +164,151 @@
 
 		#region Methods
 
-		public ITds GetConnection ()
+		public Tds GetConnection ()
 		{
-			ITds connection = null;
-			lock (list)
-			{
-				if (!initialized) 
-				{
-					for (int n = 0; n < info.PoolMinSize; n++)
-						list.Add (CreateConnection ());
-					initialized = true;
-				}
-				do {
-					if (list.Count > 0)
-					{
-						// There are available connections
-						connection = (ITds) list [list.Count - 1];
-						list.RemoveAt (list.Count - 1);
+			Tds connection = null;
+			int index;
+
+		retry:
+			// Reset the connection available event
+			connAvailable.Reset ();
+
+			index = list.Length - 1;
+			
+			do {
+				connection = list [index];
+
+				if (connection == null) {
+					// Attempt take-over of array position
+					connection = CreateConnection ();
+					(connection as Tds).poolStatus = 1;
+#if NET_2_0
+					if (Interlocked.CompareExchange<Tds> (ref list [index], connection, null) != null) {
+#else
+					object val = list [index];
+					object res = Interlocked.CompareExchange (ref val, connection, null);
+					list [index] = (Tds) val;
+					if (res != null) {
+#endif
+						// Someone beat us to the punch
+						connection = null;
+					} else {
+						continue;
+					}
+				} else {
+					if (Interlocked.CompareExchange (ref connection.poolStatus, 1, 0) != 0) {
+						// Someone else owns this connection
+						connection = null;
+					} else {
 						if (!connection.Reset ()) {
-							try {
-								connection.Disconnect ();
-							} catch {}
-							connection = null;
+							ThreadPool.QueueUserWorkItem (new WaitCallback (DestroyConnection), connection);
+							// remove connection from pool
+							list [index] = connection = null;
+							// allow slot be re-used in same run
+							continue;
+						} else {
 							continue;
 						}
 					}
+				}
+				
+				index--;
+				
+				if (index < 0) {
+					// TODO: Maintain a list of indices of released connection to save some loop over
+					// Honor timeout - if pool is full, and no connections are available within the 
+					// timeout period - just throw the exception
+					if (info.Timeout > 0 
+						&& !connAvailable.WaitOne (new TimeSpan (0, 0, info.Timeout), true))
+							throw new InvalidOperationException (
+								"Timeout expired. The timeout period elapsed before a " +
+								"connection could be obtained. A possible explanation " +
+								"is that all the connections in the pool are in use, " +
+								"and the maximum pool size is reached.");
+					goto retry;
+				}
 
-					if (connection == null && activeConnections < info.PoolMaxSize)
-					{
-						// No connections available, but the connection limit
-						// has not been reached yet, so a new one can be created
-						connection = CreateConnection();
-					}
-
-					// No available connections in the pool
-					// Wait for somewone to release one.
-					if (connection == null)
-					{
-						Monitor.Wait (list);
-					}
-				} 
-				while (connection == null);
-			}
+			} while (connection == null);
 
 			return connection;
 		}
 
-		public void ReleaseConnection (ITds tds)
+		public void ReleaseConnection (Tds connection)
 		{
-			lock (list)
-			{
-				list.Add (tds);
-				Monitor.Pulse (list);
-			}
+			connection.poolStatus = 0;
+			connAvailable.Set ();
 		}
 
 #if NET_2_0
-		public void ReleaseConnection (ref ITds tds)
+		public void ReleaseConnection (ref Tds connection)
 		{
-			lock (list)
-			{
-				if (pooling == false) {
-					try {
-						tds.Disconnect ();
-					} catch {}
-					tds = null;
-				} else {
-					list.Add (tds);
-					Monitor.Pulse (list);
-				}
+			if (pooling == false) {
+				int index = Array.IndexOf (list, connection);
+				ThreadPool.QueueUserWorkItem (new WaitCallback (DestroyConnection), connection);
+				list [index] = connection = null;
+			} else {
+				connection.poolStatus = 0;
 			}
+			connAvailable.Set ();
 		}
 
 		public void ResetConnectionPool ()
 		{
-			lock (list)
+			Tds connection = null;
+			int index = list.Length - 1;
+
+			while (index >= 0)
 			{
-				ITds connection = null;
-				while (list.Count > 0) {
-					// There are available connections
-					connection = (ITds) list [list.Count - 1];
-					list.RemoveAt (list.Count - 1);
-					if (!connection.Reset ()) {
-						try {
-							connection.Disconnect ();
-						} catch {}
-						connection = null;
-					}
+				connection = list [index];
+
+				// skip free slots
+				if (connection == null) {
+					index--;
+					continue;
 				}
+
+				if (Interlocked.CompareExchange (ref connection.poolStatus, 1, 0) == 0)
+					ThreadPool.QueueUserWorkItem (new WaitCallback (DestroyConnection), connection);
+
+				connection.Pooling = false;
+				list [index] = connection = null;
+				connAvailable.Set ();
+
+				index--;
 			}
 		}
 
-		public void ResetConnectionPool (ITds connection)
+		public void ResetConnectionPool (Tds connection)
 		{
-			lock (list)
-			{
-				if (list.Count > 0) {
-					// There are available connections
-					int index = list.IndexOf (connection);
-					if (index != -1) {
-						list.RemoveAt (index);
-						if (!connection.Reset ()) {
-							try {
-								connection.Disconnect ();
-							} catch {}
-							connection = null;
-						}
-					}
+			int index = Array.IndexOf (list, connection);
+
+			if (index != -1) {
+				if (connection != null && !connection.Reset ()) {
+					ThreadPool.QueueUserWorkItem (new WaitCallback (DestroyConnection), connection);
+					list [index] = connection = null;
+					connAvailable.Set ();
 				}
 			}
 		}
 #endif
 		
-		ITds CreateConnection ()
+		Tds CreateConnection ()
 		{
-			activeConnections++;
 			return manager.CreateConnection (info);
 		}
 		
+		void DestroyConnection (object state)
+		{
+			Tds connection = state as Tds;
+			if (connection != null) {
+				try {
+					connection.Disconnect ();
+				} finally {
+					connection = null;
+				}
+			}
+		}
+		
 		#endregion // Methods
 	}
 }
diff -urNad mono-1.9.1+dfsg~/mcs/class/Mono.Data.TdsClient/Mono.Data.TdsClient/TdsConnection.cs mono-1.9.1+dfsg/mcs/class/Mono.Data.TdsClient/Mono.Data.TdsClient/TdsConnection.cs
--- mono-1.9.1+dfsg~/mcs/class/Mono.Data.TdsClient/Mono.Data.TdsClient/TdsConnection.cs	2007-11-08 23:13:24.000000000 +0100
+++ mono-1.9.1+dfsg/mcs/class/Mono.Data.TdsClient/Mono.Data.TdsClient/TdsConnection.cs	2008-11-19 17:06:44.000000000 +0100
@@ -31,6 +31,7 @@
 //
 
 using Mono.Data.Tds.Protocol;
+using MTds = Mono.Data.Tds.Protocol.Tds;
 using System;
 using System.Collections;
 using System.Collections.Specialized;
@@ -77,7 +78,7 @@
 		TdsDataReader dataReader = null;
 
 		// The TDS object
-		ITds tds;
+		MTds tds;
 
 		#endregion // Fields
 
diff -urNad mono-1.9.1+dfsg~/mcs/class/System.Data/System.Data.SqlClient/SqlConnection.cs mono-1.9.1+dfsg/mcs/class/System.Data/System.Data.SqlClient/SqlConnection.cs
--- mono-1.9.1+dfsg~/mcs/class/System.Data/System.Data.SqlClient/SqlConnection.cs	2008-11-19 17:03:21.000000000 +0100
+++ mono-1.9.1+dfsg/mcs/class/System.Data/System.Data.SqlClient/SqlConnection.cs	2008-11-19 17:03:26.000000000 +0100
@@ -51,6 +51,9 @@
 using System.Net.Sockets;
 using System.Text;
 using System.Xml;
+#if NET_2_0
+using System.Collections.Generic;
+#endif
 
 namespace System.Data.SqlClient {
 	[DefaultEvent ("InfoMessage")]
@@ -106,7 +109,7 @@
 		XmlReader xmlReader;
 
 		// The TDS object
-		ITds tds;
+		Tds tds;
 
 		#endregion // Fields
 
@@ -441,6 +444,7 @@
 #else
 					if(pool != null) pool.ReleaseConnection (tds);
 #endif
+					pool = null;
 				}else
 					if(tds != null) tds.Disconnect ();
 			}
@@ -544,6 +548,7 @@
 					if(!ParseDataSource (dataSource, out port, out serverName))
 						throw new SqlException(20, 0, "SQL Server does not exist or access denied.",  17, "ConnectionOpen (Connect()).", dataSource, parms.ApplicationName, 0);
 					tds = new Tds70 (serverName, port, PacketSize, ConnectionTimeout);
+					tds.Pooling = false;
 				}
 				else {
 					if(!ParseDataSource (dataSource, out port, out serverName))
@@ -570,8 +575,6 @@
 						pool.ReleaseConnection (tds);
 					throw;
 				}
-			} else if (connectionReset) {
-				tds.Reset ();
 			}
 
 			disposed = false; // reset this, so using () would call Close ().
@@ -1684,12 +1687,14 @@
 
 		public static void ClearAllPools ()
 		{
+#if NET_2_0
+			IDictionary <string, TdsConnectionPool> pools = SqlConnection.sqlConnectionPools.GetConnectionPool ();
+#else			
 			Hashtable pools = SqlConnection.sqlConnectionPools.GetConnectionPool ();
+#endif
 			foreach (TdsConnectionPool pool in pools.Values) {
 				if (pool != null) {
 					pool.ResetConnectionPool ();
-					ITds tds = pool.GetConnection ();
-					tds.Pooling = false;
 				}
 			}
 		}
@@ -1697,9 +1702,9 @@
 		public static void ClearPool (SqlConnection connection)
 		{
 			if (connection.pooling) {
-				connection.pooling = false;
-				if (connection.pool != null)
-					connection.pool.ResetConnectionPool (connection.Tds);
+				TdsConnectionPool pool = sqlConnectionPools.GetConnectionPool (connection.ConnectionString);
+				if (pool != null)
+					pool.ResetConnectionPool ();
 			}
 		}
 
